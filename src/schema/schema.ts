import * as S from '@effect/schema/Schema'
import { formatError } from '@effect/schema/TreeFormatter'
import { Effect as E, pipe } from 'effect'

const optional = <A>(s: S.Schema<A>) => S.optional(s, { exact: true })

export class ParsingError extends S.TaggedError<ParsingError>()('ParsingError', {
  message: S.string,
  detail: S.string,
}) {}

/* Components */

export const VerifyEmailLink = S.struct({
  method: S.literal('link'),
  redirectUrl: S.string
})

export type VerifyEmailLink = S.Schema.Type<typeof VerifyEmailLink>

export const VerifyEmailCode = S.struct({
  method: S.literal('code'),
})

export type VerifyEmailCode = S.Schema.Type<typeof VerifyEmailCode>

export const VerifyEmail = S.union(VerifyEmailLink, VerifyEmailCode)

export type VerifyEmail = S.Schema.Type<typeof VerifyEmail>

const PublicKey = S.literal('public-key')

const PubKeyCredParams = S.struct({
  alg: S.number,
  type: PublicKey,
})

const AuthenticatorAttachment = S.union(S.literal('cross-platform'), S.literal('platform'))

const base64url = S.string

export const Transport = S.union(
  S.literal('ble'),
  S.literal('hybrid'),
  S.literal('internal'),
  S.literal('nfc'),
  S.literal('usb'),
)

const Credential = S.struct({
  id: base64url,
  type: PublicKey,
  transports: optional(S.mutable(S.array(Transport))),
})

export const UserVerification = S.union(
  S.literal('discouraged'),
  S.literal('preferred'),
  S.literal('required'),
)

export type UserVerification = S.Schema.Type<typeof UserVerification>

const ResidentKey = S.union(S.literal('discouraged'), S.literal('preferred'), S.literal('required'))

const AuthenticatorSelection = S.struct({
  authenticatorAttachment: optional(AuthenticatorAttachment),
  requireResidentKey: optional(S.boolean),
  residentKey: optional(ResidentKey),
  userVerification: optional(UserVerification),
})

const AuthType = S.union(S.literal('email'), S.literal('passkey'))

/* Registration */

/**
 * Required by the browser to generate a passkey.
 * Wrap this into a publicKey and pass into createRequestFromJSON
 * i.e. createRequestFromJSON({ publicKey: RegistrationOptions })
 */
export const RegistrationOptions = S.struct({
  rp: S.struct({
    name: S.string,
    id: optional(base64url),
  }),
  user: S.struct({
    id: base64url,
    name: S.string,
    displayName: S.string,
  }),
  challenge: base64url,
  pubKeyCredParams: S.mutable(S.array(PubKeyCredParams)),
  timeout: optional(S.number),
  excludeCredentials: optional(S.mutable(S.array(Credential))),
  authenticatorSelection: optional(AuthenticatorSelection),
  attestation: optional(
    S.union(S.literal('direct'), S.literal('enterprise'), S.literal('indirect'), S.literal('none')),
  ),
  extensions: optional(
    S.struct({
      appid: optional(S.string),
      appidExclude: optional(S.string),
      credProps: optional(S.boolean),
    }),
  ),
})

export type RegistrationOptions = S.Schema.Type<typeof RegistrationOptions>

/** Public key credential (generated by the browser) */
export const RegistrationCredential = S.struct({
  id: S.string,
  type: PublicKey,
  rawId: S.string,
  authenticatorAttachment: S.optional(S.nullable(AuthenticatorAttachment)),
  response: S.struct({
    clientDataJSON: S.string,
    attestationObject: S.string,
    transports: S.mutable(S.array(Transport)),
  }),
  clientExtensionResults: S.struct({
    appid: S.optional(S.boolean),
    appidExclude: S.optional(S.boolean),
    credProps: S.optional(S.struct({ rk: S.boolean })),
  }),
})

export type RegistrationCredential = S.Schema.Type<typeof RegistrationCredential>

/* Authentication */

export const AuthenticationOptions = S.struct({
  challenge: S.string,
  timeout: optional(S.number),
  rpId: optional(S.string),
  allowCredentials: optional(S.mutable(S.array(Credential))),
  userVerification: optional(UserVerification),
  extensions: optional(
    S.struct({
      appid: optional(S.string),
      credProps: optional(S.boolean),
      hmacCreateSecret: optional(S.boolean),
    }),
  ),
})

export type AuthenticationOptions = S.Schema.Type<typeof AuthenticationOptions>

/** Browser's response to the backend's auth challenge  */
export const AuthenticationCredential = S.struct({
  id: S.string,
  type: PublicKey,
  rawId: S.string,
  authenticatorAttachment: S.optional(S.nullable(S.string)),
  response: S.struct({
    clientDataJSON: S.string,
    authenticatorData: S.string,
    signature: S.string,
    userHandle: S.nullable(S.string),
  }),
  clientExtensionResults: S.struct({
    appid: S.optional(S.boolean),
    appidExclude: S.optional(S.boolean),
    credProps: S.optional(
      S.struct({
        rk: S.boolean,
      }),
    ),
  }),
})

export type AuthenticationCredential = S.Schema.Type<typeof AuthenticationCredential>

/** Represents a successful registration/authentication */
export const Principal = S.struct({
  token: S.string,
  user: S.struct({
    id: S.string,
    givenName: S.string,
    familyName: S.string,
    email: S.string,
    emailVerified: S.boolean,
  }),
  socials: S.struct({
    google: S.optional(
      S.struct({
        id: S.string,
        givenName: S.string,
        familyName: S.string,
        email: S.string,
        emailVerified: S.boolean
      })
    )
  }),
  authStatement: S.struct({
    authType: AuthType,
    userVerified: S.boolean,
    authTimestamp: S.Date,
  }),
  expireAt: S.Date,
})

export type Principal = S.Schema.Type<typeof Principal>

export const AuthenticationRequired = S.struct({
  requiredAuthType: AuthType,
})

/* Utils */

export const createParser =
  <A, E, R>(schema: S.Schema<A, E, R>) =>
  (input: unknown) =>
    pipe(
      S.decodeUnknown(schema)(input),
      E.mapError(formatError),
      E.mapError(detail => new ParsingError({ message: 'Unable to parse input', detail })),
    )
